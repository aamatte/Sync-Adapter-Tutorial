\documentclass[10pt]{extarticle}

%Paquetes utilizados en esta tarea
\usepackage{logo}
\usepackage{enumerate}
\usepackage{fullpage}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{epsfig}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage[hidelinks]{hyperref}
\usepackage{algorithmic}
\usepackage[nothing]{algorithm}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.5,0}
\definecolor{dkblue}{rgb}{0,0,0.5}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{purple}{rgb}{0.4,0,0.4}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{dkblue},
  keywordstyle=\color{dkblue},
  commentstyle=\color{gray},
  stringstyle=\color{dkgreen},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
%Definiciones de comandos, para reutilizar secuencias frecuentes o ahorrar
% c�digo
\newcommand{\RR}{\mathbb{R}}
\newcommand{\lb}{\\~\\}
\newcommand{\la}{\leftarrow}

\newcommand{\twopartdef}[4]
{
	\left\{
		\begin{array}{ll}
			#1 &  \text{si }#2 \\
			#3 &  \text{si }#4
		\end{array}
	\right.
}

\newcommand{\threepartdef}[6]
{
	\left\{
		\begin{array}{ll}
			#1 &  \text{si }#2 \\
			#3 &  \text{si }#4 \\
			#5 &  \text{si }#6
		\end{array}
	\right.
}

\makeatletter

\makeatother

\begin{document}

\begin{tabular}{ccl}
\begin{tabular}{c}
\psfig{file=puclogo.eps}
\end{tabular}
&\ \ \ & 
\begin{tabular}{l}
PONTIFICIA UNIVERSIDAD CATÓLICA DE CHILE\\
ESCUELA DE INGENIERÍA\\
DEPARTAMENTO DE CIENCIAS DE LA COMPUTACIÓN\\
MECOLAB
\end{tabular}
\end{tabular}

\begin{center}
\bf Andrés Matte Vallejos\\
\bf matte.andres@gmail.com\\
\bf 1er semestre del 2015\lb

\vspace{0.5cm}

\bf {\Huge Tutorial Sync Adapter}
\end{center}

\tableofcontents

\newpage

\section{Introducción}

\paragraph{}
Mantener una aplicación móvil no sincronizada con la web la vuelve prácticamente inservible. Hoy en día es difícil pensar en una aplicación importante que no descargue o suba datos a algún servidor. Claramente este feature hace que una aplicación luzca más profesional y da una mejor experiencia de usuario. Por ejemplo a un usuario de Facebook le gustaría que un cambio de foto de perfil no solo se realice en la web, si no que también ocurra en todos sus dispositivos móviles.

\paragraph{}
Hay muchas formas de realizar una sincronización de datos con un servidor. Si bien cada desarrollador puede implementar su propio sistema, no hay necesidad de reinventar la rueda. O en este caso, para qué vamos a reinventar algo mucho más complejo que una rueda: un Sync Adapter. Este framework ayuda a manejar y automatizar las transferencias de datos.


\subsection{Beneficios}

\begin{enumerate}
 \item Ejecución automatizada: la sincronización estará definida de acuerdo a tu configuración y se ejecutará automáticamente de acuerdo a eso. Con esto podemos eliminar el botón de refresh.
 \item Revisión de conectividad: por ejemplo, si en algún momento no hay conexión a internet y corresponde una sincronización el framework se encargará de realizar la sincronización nuevamente cuando la haya.
 \item Encolación de transferencias fallidas: si se está descargando un archivo y esto falla, se vuelve a intentar.
 \item Gasta menos batería: muchas veces el framework realizará la sincronización de más de una aplicación al mismo tiempo. De esta forma la radio se enciende con menor frecuencia.
 \item Centralización de la transferencia: la sincronización de los datos se realiza toda al mismo tiempo y en el mismo lugar.
 \item Manejo de cuenta y autenticación: si el usuario de tu aplicación requiere credenciales especiales se puede integrar el manejo de cuentas y autenticación en la transferencia.
\end{enumerate}

\subsection{Qué haremos}

\paragraph{}
Durante el siguiente tutorial se creará una aplicación sencilla que liste a los integrantes de un curso. Se podrá añadir estudiantes, tanto en el servidor web como en la aplicación android, y se deberán mantener sincronizados los datos a través de un sync adapter. No se entrará en temas que escapan del objetivo del tutorial como el servidor o sobre como se realizan los requests. De todas formas en \url{https://github.com/aamatte/ListaAlumnosAndroid} se puede revisar el código de la aplicación utilizada para los ejemplos\footnote{Algunos detalles en el código pueden variar un poco en el tiempo pero los conceptos serán los mismos}.


\subsection{Qué se necesita}

\paragraph{}
Para que el Sync Adapter esté funcionando necesitamos implementar seis componentes, donde cada una juega un papel importante:

\begin{enumerate}
 \item Base de datos
 \item Content Provider
 \item Authenticator
 \item Authenticator service
 \item Clase Sync Adapter
 \item Bound Service
\end{enumerate}



\section{Base de datos}

\paragraph{}
En android se pueden guardar información de diferentes maneras, pero en este caso utilizaremos bases de datos. Usaremos SQLite, el sistema por defecto para android. En esta parte del tutorial no se ahondará de sobremanera debido a que es un tema transversal y hay mucha documentación al respecto. Se necesitará lo siguiente:

\begin{enumerate}
 \item Definir un esquema y sus constantes
 \item Crear base de datos y tablas
 \item Crear métodos CRUD
\end{enumerate}

\subsection{Definir un esquema y sus constantes}

\paragraph{}
Una vez que el modelo relacional esté definido este se debe plasmar en una clase que llamaremos DatabaseContract. Esta tendrá definidas como String los nombres de las tablas, de las columnas y algunas operaciones importantes. Gracias a esto podemos cambiar el nombre de, por ejemplo, una columna sin la necesidad de cambiar el resto de nuestro código.

\begin{lstlisting}
// DatabaseContract.java
public final class DatabaseContract {

    public DatabaseContract() {
    }

    public static abstract class Students implements BaseColumns {
		// BaseColumns nos entrega las constantes _ID y _COUNT
		
        public static final String TABLE_NAME = "STUDENTS";
        public static final String COLUMN_NAME_STUDENT_NAMES = "names";
        public static final String COLUMN_NAME_FIRST_LASTNAME = "firstlastname";
        public static final String COLUMN_NAME_SECOND_LASTNAME = "secondlastname";
        public static final String COLUMN_ID_CLOUD = "idcloud";

        public static final String TEXT_TYPE = " TEXT";
        public static final String INTEGER_TYPE = " INTEGER";
        public static final String COMMA_SEP = ",";

        public static final String SQL_CREATE_STUDENTS_TABLE =
                "CREATE TABLE " + Students.TABLE_NAME + " (" +
                        Students._ID + " INTEGER PRIMARY KEY," +
                        Students.COLUMN_NAME_STUDENT_NAMES + TEXT_TYPE + COMMA_SEP +
                        Students.COLUMN_NAME_FIRST_LASTNAME + TEXT_TYPE + COMMA_SEP +
                        Students.COLUMN_NAME_SECOND_LASTNAME + TEXT_TYPE + COMMA_SEP+
                        Students.COLUMN_ID_CLOUD + INTEGER_TYPE +
                        " )";

        public static final String SQL_DELETE_STUDENTS =
                "DROP TABLE IF EXISTS " + Students.TABLE_NAME;
    }
}
\end{lstlisting}

\paragraph{}
Los datos que pongas en tu base de datos estarán seguros. Esto debido a que android las guarda en un espacio de disco privado al que solo tiene acceso tu aplicación. Si se quiere compartir los datos recolectados hay que implementar un Content Provider, tema de la siguiente sección.

\subsection{Crear base de datos y tablas}

\paragraph{}
Ahora utlizaremos la clase SQLiteOpenHelper, una API para poder interactuar con nuestra base de datos. Cuando utilizas esta clase el sistema realiza las operaciones de larga duración cuando tu lo decidas y no en el inicio de la aplicación. Lo único que se debe hacer es llamar a $getWritableDatabase()$ o a $getReadableDatabase()$. 
\paragraph{}
Las instancias retornadas por estos métodos están especialmente configuradas para realizar las operaciones especificadas. Esto quiere decir que $getWritableDatabase()$ retornará una instancia en el que la escritura de datos será rápida en desmedro de la lectura. Con $getReadableDatabase()$ no se podrá escribir y tendrá una lectura más rápida. Además, al llamar a estos métodos se crea la base de datos en caso de no existir aún.

\paragraph{}
Otro método escencial es $onCreate(SQLiteDatabase)$. Ahí es donde se ejecuta el código SQL para crear las tablas de la base de datos. También están $onUpgrade(SQLiteDatabase)$ y $onDowngrade(SQLiteDatabase)$.

\begin{lstlisting}
// StudentsDbHelper.java
// Documentacion:
// http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html
import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;

public class StudentsDbHelper extends SQLiteOpenHelper {

    public static final int DATABASE_VERSION = 1;
    public static final String DATABASE_NAME = "Students.db";

    private static StudentsDbHelper sInstance;

    private StudentsDbHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }
	
	// Nos aseguramos de que solo haya una instancia para evitar errores.
	// Mas detalles: 
	// http://www.androiddesignpatterns.com/2012/05/correctly-managing-your-sqlite-database.html
    public static synchronized StudentsDbHelper getInstance(Context context) {
        if (sInstance == null) {
            sInstance = new StudentsDbHelper(context.getApplicationContext());
        }
        return sInstance;
    }
	
    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(DatabaseContract.Students.SQL_CREATE_STUDENTS_TABLE);
    }
	
	// Cambia la version del esquema en caso de haber modificaciones.
	// Por simplicidad asumimos que esto no va a pasar y tan solo se resetea la db.
    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        db.execSQL(DatabaseContract.Students.SQL_DELETE_STUDENTS);
        onCreate(db);
    }
}
\end{lstlisting}

\paragraph{}
Para tener acceso a la base de datos se debe hacer lo siguiente:
\begin{lstlisting}
StudentsDbHelper mDbHelper = StudentsDbHelper.newInstance();
SQLiteDatabase db = mDbHelper.getWritableDatabase();
\end{lstlisting}
O en el otro caso:
\begin{lstlisting}
StudentsDbHelper mDbHelper = StudentsDbHelper.newInstance();
SQLiteDatabase db = mDbHelper.getReadableDatabase();
\end{lstlisting}

\subsection{Crear métodos CRUD}

\subsubsection{Agregar datos}
\paragraph{}
Para insertar datos se deben ingresar los datos del elemento a añadir en ContentValues y usar el método insert. El segundo argumento especifica la columna en que la base de datos puede puede insertar null si values (los datos a ingresar) está vacio. Si es que no quieres que se ingrese un record con valores vacios debes setearlo como null. Por ejemplo, si se quiere añadir un estudiante:
	
\begin{lstlisting}
// Insertar nuevo estudiante

if (mDbHelper == null) {
    mDbHelper = StudentsDbHelper.getInstance(getActivity());
}
SQLiteDatabase db = mDbHelper.getWritableDatabase();

ContentValues values = new ContentValues();
values.put(DatabaseContract.Students.COLUMN_NAME_STUDENT_NAMES, student.getNames());
values.put(DatabaseContract.Students.COLUMN_NAME_FIRST_LASTNAME, student.getFirstLastname());
values.put(DatabaseContract.Students.COLUMN_NAME_SECOND_LASTNAME, student.getSecondLastname());
values.put(DatabaseContract.Students.COLUMN_ID_CLOUD, student.getIdCloud());

// Retorna la columna en la que fue insertado
long success = db.insert(
        DatabaseContract.Students.TABLE_NAME, 
        null,								  
        values);
        
if (success >= 0) return true;
return false;
     
\end{lstlisting}

\subsubsection{Consultar datos}
\paragraph{}
Para esto se usa el método query(). Si no se quiere filtrar y solo obtener toda la información de la tabla se pueden dejar todos los valores como null excepto el nombre de la tabla. Para seleccionar todos los estudiantes:

\begin{lstlisting}
// Seleccionar todos los estudiantes

if (mDbHelper == null) {
    mDbHelper = StudentsDbHelper.getInstance(getActivity());
}

// Selecciono las columnas que debe retornar de cada fila. Podria dejarse como null y me retorna todas.
String[] projection = {DatabaseContract.Students.COLUMN_NAME_STUDENT_NAMES,
                       DatabaseContract.Students.COLUMN_NAME_FIRST_LASTNAME,
                       DatabaseContract.Students.COLUMN_NAME_SECOND_LASTNAME,
                       DatabaseContract.Students.COLUMN_ID_CLOUD
                       };

// Se deja como null porque no se requiere filtrar. Por ejemplo, si se necesitara filtrar por primer apellido:
// String selection = DatabaseContract.Students.COLUMN_NAME_FIRST_LASTNAME + "= ?"
String selection = null;

// Que el primer apellido sea Perez:
// String[] selectionArgs = new String[]{ "Perez" };
// En este caso dejamos como null
String[] selectionArgs = null;

SQLiteDatabase db = mDbHelper.getReadableDatabase();

Cursor c = db.query(DatabaseContract.Students.TABLE_NAME,   // Tabla
                    projection,                             // Columnas a retornar
                    selection,                              // Columnas de WHERE
                    selectionArgs,                          // Valores de WHERE
                    null,                                   // Group by
                    null,                                   // Filtro por columnas de grupos
                    DatabaseContract.Students.COLUMN_NAME_FIRST_LASTNAME +" ASC"); // Ordenados

ArrayList<Student> studentsInDb = new ArrayList<Student>();

c.moveToFirst();

if (c.getCount()<1){
    return false;
}

while (c.moveToNext()){
    String names = c.getString(c.getColumnIndexOrThrow(DatabaseContract.Students.COLUMN_NAME_STUDENT_NAMES))
    		    .toUpperCase();
    String firstLast = c.getString(c.getColumnIndexOrThrow(DatabaseContract.Students.COLUMN_NAME_FIRST_LASTNAME))
    		    .toUpperCase();
    String secondLast = c.getString(c.getColumnIndexOrThrow(DatabaseContract.Students.COLUMN_NAME_SECOND_LASTNAME))
    			.toUpperCase();
    int idCloud = c.getInt(c.getColumnIndexOrThrow(DatabaseContract.Students.COLUMN_ID_CLOUD));
    
    studentsInDb.add(new Student(names, firstLast, secondLast, idCloud));
}
     
\end{lstlisting}

\subsubsection{Borrar datos}
\paragraph{}
Se utiliza el método delete.

\subsubsection{Actualizar datos}
\paragraph{}
Se utiliza el método update.


\section{Content Provider}

\paragraph{}
Un content provider es exactamente lo que su nombre dice, un proveedor de contenido o de datos. Ofrece un esquema estructurado para acceder, crear, borrar o actualizar los datos que se pongan a disposición a través de él. En definitiva es la forma en que tu aplicación ofrece sus datos para que puedan ser consumidos o editados por procesos externos a ella o por otras aplicaciones sin la necesidad de que esta esté 'abierta'.

\paragraph{}
Se pueden usar incluso como una forma de abstraer implementación de un sistema de datos complejo frente al resto de los desarrolladores de una misma aplicación. De esta forma el resto de los integrantes del equipo solo deben estar al tanto de los estándares de comunicación con el content provider y no necesitan preocuparse de detalles de la implementación. 

\paragraph{}
En esta sección cubriremos los siguientes temas:
\begin{enumerate}
	\item Funcionamiento general
	\item Content URIs
	\item Clase Contrato
	\item Clase Content Provider
	\item Cómo utilizar el Content Provider
	\item Permisos
\end{enumerate}

\subsection{Funcionamiento general}

\paragraph{}
Como se aprecia en la Figura~\ref{fig:flujo_content_provider} el flujo parte desde tu aplicación obteniendo una instancia de ContentResolver\footnote{ContentResolver: http://developer.android.com/reference/android/content/ContentResolver.html}. Luego, a través de esta se hace una consulta pasando como primer parámetro una URI que hace referencia a un conjunto de datos que ofrece un content provider específico. Es importante saber que pueden haber muchos content providers disponibles, cada uno con su conjunto de URIs (un URI para cada conjunto de datos ofrecido). Por ejemplo, android provee Contacts Provider\footnote{Contacts provider: http://developer.android.com/guide/topics/providers/contacts-provider.html} y Calendar Provider\footnote{Calendar provider: http://developer.android.com/guide/topics/providers/calendar-provider.html}. En la próxima sección se entrará más en detalles en el diseño de las URIs.

\paragraph{}
Nuestra instancia de ContentResolver decide a qué provider hacer la consulta basado en la URI. Luego el content provider determina a qué conjunto de datos debe afectar (también basado en la URI) e interactúa con la base de datos para realizar la operación que fue invocada.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{ContentProviderGeneral.png}
    \caption{Flujo general de content provider}
    \label{fig:flujo_content_provider}
\end{figure}



\subsection{Content URIs}

\paragraph{}
Un content URI es un identificador de un conjunto de datos en un provider. Está formado por el identificador del provider (authority) y por un nombre que indica a la tabla o al contenido del provider que hace referencia. Cuando se llama a un método para acceder a algún conjunto de datos se debe incluir en los parámetros una URI para que el ContentResolver pueda determinar a qué provider le corresponde manejar el llamado, y para que el provider pueda determinar sobre que datos realizar la operación.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{provider_uri_explicacion.png}
    \caption{Estructura content URI}
    \label{fig:estructura_content_URI}
\end{figure}



\subsubsection{Authority}

\paragraph{}
La authority es el identificador de tu aplicación dentro de android. Por lo general el formato de este viene dado por el package de la aplicación más 'provider'. Por ejemplo, en el caso de nuestra aplicación en la que se basa el código del tutorial es \textit{com.example.andres.myapplication.provider}. En el package (y en este caso, en la authority) se suele utilizar como primeras palabras un dominio de internet, al revés, al cual pertenece la aplicación. En este caso asumimos que hay un dominio con la ruta \textit{andres.example.com}.

\subsubsection{Estructura de rutas URI}

\paragraph{}
Para el content provider se puede diseñar una estructura nueva de los datos de acuerdo a lo que se quiera ofrecer. En la clase contrato definiremos nuevas tablas (que pueden ser iguales a las de tu base de datos o no) que conformarán la estructura de rutas. Por ejemplo, en nuestro caso solo definiremos una tabla Students igual a la de nuestra base de datos. Claramente se pueden hacer estructuras más complejas con tablas anidadas y más esoterismos, pero no se cubrirán en este tutorial\footnote{Para más detalles mirar: \url{http://developer.android.com/guide/topics/providers/content-provider-creating.html\#ContentURI}}.

\paragraph{}
Para nuestra aplicación definiremos dos URIs, una para obtener la lista completa de estudiantes y otra para obtener a un estudiante en particular basandonos en su ID. La primera es exactamente como la que está en la Figura~\ref{fig:estructura_content_URI}. La segunda debe poder soportar llamados del tipo 
\begin{center}
\textit{content://com.example.andres.myapplication.provider/students/3},
\end{center}
donde 3 es el id del estudiante a seleccionar. Para poder soportar esto debemos definir la URI de la siguiente manera:

\begin{center}
\textit{content://com.example.andres.myapplication.provider/students/\#}
\end{center}


\subsection{Clase Contrato}

\paragraph{}
La clase contrato es la que contiene todos los URIs, MIME Types y constantes necesarias para poder tener un protocolo de comunicación fijo entre los distintos procesos que utilizan el provider. Esta clase es la que debes compartir con otros desarrolladores si quieres que usen tu provider, ya que con ella les proveerás todos las valores necesarios para que se puedan comunicar con el de manera correcta.

\paragraph{}
A continuación se presenta el código de la clase contrato de nuestra aplicación de ejemplo. Los conceptos involucrados se explicarán luego de eso.

\begin{lstlisting}

import android.content.ContentResolver;
import android.net.Uri;
import android.provider.BaseColumns;

/**
 *  Esta clase provee las constantes y URIs necesarias para trabajar con el StudentsProvider
 */
public final class StudentsContract {

    public static final String AUTHORITY = "com.example.andres.myapplication.provider";
    public static final Uri BASE_URI = Uri.parse("content://" + AUTHORITY);
    public static final Uri STUDENTS_URI = Uri.withAppendedPath(StudentsContract.BASE_URI, "/students");

    /*
        MIME Types
        Para listas se necesita  'vnd.android.cursor.dir/vnd.com.example.andres.provider.students
        Para items se necesita 'vnd.android.cursor.item/vnd.com.example.andres.provider.students'
        La primera parte viene esta definida en constantes de ContentResolver
     */
    public static final String URI_TYPE_STUDENT_DIR = ContentResolver.CURSOR_DIR_BASE_TYPE +
            "/vnd.com.example.andres.provider.students";

    public static final String URI_TYPE_STUDENT_ITEM = ContentResolver.CURSOR_ITEM_BASE_TYPE +
            "/vnd.com.example.andres.provider.students";

    /*
        Tabla definida en provider. Aca podria ser una distinta a la de la base de datos,
        pero consideramos la misma.
     */
    public static final class StudentsColumns implements BaseColumns{

        private StudentsColumns(){}

        public static final String NAMES = "names";
        public static final String FIRST_LASTNAME = "firstlastname";
        public static final String SECOND_LASTNAME = "secondlastname";
        public static final String ID_CLOUD = "idcloud";

        public static final String DEFAULT_SORT_ORDER = FIRST_LASTNAME + " ASC";

    }

}
     
\end{lstlisting}

\paragraph{}
De lo que está presente en la clase contrato y no se ha hablado es de los MIME Types. Estos conforman una manera estandar de clasificar los tipos de archivos o datos. Estos tipos son los mismos siempre, independiente del sistema operativo o de cualquier otra variante que se presente. Un MIME Type tiene dos partes: un tipo y un sub-tipo que están separados por un slash (/). Por ejemplo, las imagenes de formato JPEG tienen el MIME Type \textit{image/jpeg}.

\paragraph{}
En el caso del provider se especifican dos MIME Types principales. El primero es para items individuales, donde el tipo viene dado por \textit{\textbf{vnd.android.cursor.item}} y el subtipo (para nuestro provider) por \textit{/vnd.com.example.andres.provider.students}. El otro es para listas, donde el tipo viene dado por \textit{\textbf{vnd.android.cursor.dir}} y el subtipo (para nuestro provider) por   \textit{/vnd.com.example.andres.provider.students} (igual que para el de items individuales). De esta forma los MIME Types completos quedan como se especifica en el código.

\paragraph{}
Los MIME Types son importantes debido a que con ellas el desarrollador puede determinar el tipo de dato que se le retornará si utiliza una URI determinada en una consulta. No hay que olvidar que esta clase es principalmente un apoyo para que otros puedan utilizar los datos que les provees, por lo tanto se debe ser consistente y claro en la implementación.

\subsection{Clase Content Provider}

	
\subsection{Cómo utilizar el Content Provider}


\subsection{Permisos}



\section{Authenticator}


\section{Authenticator service}


\section{Clase Sync Adapter}


\section{Bound Service}


\end{document}
